/// <reference types="node" />

import { access, mkdir, readFile, stat, writeFile } from 'node:fs/promises'
import path from 'node:path'

import {
  CONFLICT_STRATEGIES,
  DEFAULT_STUDIO_CONFIG,
} from '@/cli/types'
import type { RuntimePathCheck, StudioConfig } from '@/cli/types'

const CONFIG_EXPORT_PATTERN =
  /export const studioConfig = (\{[\s\S]*\}) as const\s*export default studioConfig/
const SCRIPT_NAME_PATTERN = /^[a-zA-Z0-9:_-]+$/

function isProjectRelativePath(value: string): boolean {
  const normalized = value.trim()
  if (!normalized || path.isAbsolute(normalized)) {
    return false
  }

  const parts = normalized.split(/[\\/]+/)
  return parts.every((part) => part.length > 0 && part !== '.' && part !== '..')
}

export function normalizeStudioConfig(
  value: Partial<StudioConfig> | null | undefined,
): StudioConfig {
  return {
    scriptName: value?.scriptName ?? DEFAULT_STUDIO_CONFIG.scriptName,
    uiPath: value?.uiPath ?? DEFAULT_STUDIO_CONFIG.uiPath,
    componentsPath: value?.componentsPath ?? DEFAULT_STUDIO_CONFIG.componentsPath,
    configPath: value?.configPath ?? DEFAULT_STUDIO_CONFIG.configPath,
    stylesPath: value?.stylesPath ?? DEFAULT_STUDIO_CONFIG.stylesPath,
    port: value?.port ?? DEFAULT_STUDIO_CONFIG.port,
    conflictStrategy:
      value?.conflictStrategy ?? DEFAULT_STUDIO_CONFIG.conflictStrategy,
  }
}

export function validateStudioConfig(config: StudioConfig): string[] {
  const issues: string[] = []

  if (!SCRIPT_NAME_PATTERN.test(config.scriptName.trim())) {
    issues.push(
      'scriptName must use only letters, numbers, ":", "-", or "_" characters.',
    )
  }

  if (!isProjectRelativePath(config.uiPath)) {
    issues.push('uiPath must be a project-relative path.')
  }

  if (!isProjectRelativePath(config.componentsPath)) {
    issues.push('componentsPath must be a project-relative path.')
  }

  if (!isProjectRelativePath(config.configPath)) {
    issues.push('configPath must be a project-relative path.')
  }

  if (!isProjectRelativePath(config.stylesPath)) {
    issues.push('stylesPath must be a project-relative path.')
  }

  if (!Number.isInteger(config.port) || config.port < 1 || config.port > 65_535) {
    issues.push('port must be an integer between 1 and 65535.')
  }

  if (!CONFLICT_STRATEGIES.includes(config.conflictStrategy)) {
    issues.push('conflictStrategy must be one of: ask, skip, overwrite.')
  }

  return issues
}

export function serializeStudioConfig(config: StudioConfig): string {
  const orderedConfig: StudioConfig = {
    scriptName: config.scriptName,
    uiPath: config.uiPath,
    componentsPath: config.componentsPath,
    configPath: config.configPath,
    stylesPath: config.stylesPath,
    port: config.port,
    conflictStrategy: config.conflictStrategy,
  }

  return [
    '// Generated by shadcn-studio init.',
    '// Keep keys quoted so the CLI can parse this file safely.',
    '',
    `export const studioConfig = ${JSON.stringify(orderedConfig, null, 2)} as const`,
    '',
    'export default studioConfig',
    '',
  ].join('\n')
}

export function parseStudioConfig(raw: string): StudioConfig | null {
  const match = raw.match(CONFIG_EXPORT_PATTERN)
  if (match) {
    try {
      const parsed = JSON.parse(match[1]) as Partial<StudioConfig>
      return normalizeStudioConfig(parsed)
    } catch {
      return null
    }
  }

  try {
    const parsed = JSON.parse(raw) as Partial<StudioConfig>
    return normalizeStudioConfig(parsed)
  } catch {
    return null
  }
}

export function resolveStudioConfigPath(
  projectRoot: string,
  configPath = DEFAULT_STUDIO_CONFIG.configPath,
): string {
  return path.resolve(projectRoot, configPath)
}

export async function loadStudioConfig(options: {
  projectRoot: string
  configPath?: string
}): Promise<{ config: StudioConfig; absoluteConfigPath: string }> {
  const absoluteConfigPath = resolveStudioConfigPath(
    options.projectRoot,
    options.configPath,
  )
  const raw = await readFile(absoluteConfigPath, 'utf8')
  const config = parseStudioConfig(raw)
  if (!config) {
    throw new Error(
      `Unable to parse studio config at ${absoluteConfigPath}. Run "shadcn-studio init" again.`,
    )
  }

  const issues = validateStudioConfig(config)
  if (issues.length > 0) {
    throw new Error(
      `Invalid studio config at ${absoluteConfigPath}:\n- ${issues.join('\n- ')}`,
    )
  }

  return {
    config,
    absoluteConfigPath,
  }
}

export async function writeStudioConfig(options: {
  projectRoot: string
  config: StudioConfig
}): Promise<string> {
  const absoluteConfigPath = resolveStudioConfigPath(
    options.projectRoot,
    options.config.configPath,
  )
  await mkdir(path.dirname(absoluteConfigPath), { recursive: true })
  await writeFile(absoluteConfigPath, serializeStudioConfig(options.config), 'utf8')
  return absoluteConfigPath
}

export function getRuntimePathChecks(
  projectRoot: string,
  config: StudioConfig,
): RuntimePathCheck[] {
  return [
    {
      key: 'uiPath',
      expectedKind: 'directory',
      absolutePath: path.resolve(projectRoot, config.uiPath),
      exists: false,
    },
    {
      key: 'componentsPath',
      expectedKind: 'file',
      absolutePath: path.resolve(projectRoot, config.componentsPath),
      exists: false,
    },
    {
      key: 'stylesPath',
      expectedKind: 'file',
      absolutePath: path.resolve(projectRoot, config.stylesPath),
      exists: false,
    },
  ]
}

export async function validateRuntimePaths(
  projectRoot: string,
  config: StudioConfig,
): Promise<RuntimePathCheck[]> {
  const checks = getRuntimePathChecks(projectRoot, config)

  for (const check of checks) {
    try {
      await access(check.absolutePath)
      const entry = await stat(check.absolutePath)
      check.exists =
        check.expectedKind === 'file' ? entry.isFile() : entry.isDirectory()
    } catch {
      check.exists = false
    }
  }

  return checks
}
